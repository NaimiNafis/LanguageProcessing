        -:    0:Source:scan.c
        -:    0:Graph:scan.gcno
        -:    0:Data:scan.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <ctype.h>
        -:    4:#include <string.h>
        -:    5:#include "scan.h"
        -:    6:
        -:    7:FILE *fp;  // File pointer to handle input
        -:    8:char string_attr[MAXSTRSIZE];  // Store string attributes
        -:    9:int num_attr;  // Store numerical attributes
        -:   10:char cbuf = '\0';  // Buffer for the current character being read
        -:   11:int linenum = 1;  // Line number tracker
        -:   12:
        -:   13:// Helper function declarations
        -:   14:int match_keyword(const char *token_str);
        -:   15:int process_identifier(const char *token_str);
        -:   16:int process_symbol(char *token_str);
        -:   17:int process_number(const char *token_str);
        -:   18:int process_string_literal(void);
        -:   19:int skip_whitespace_and_comments(void);
        -:   20:int check_token_size(int length);
        -:   21:
        -:   22:// Initialize file reading
function init_scan called 1 returned 100% blocks executed 75%
        1:   23:int init_scan(char *filename) {
        1:   24:    fp = fopen(filename, "r");
        1:   25:    if (fp == NULL) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   26:        error("Unable to open file.");
    #####:   27:        return -1;
        -:   28:    }
        1:   29:    linenum = 1;
        1:   30:    cbuf = (char) fgetc(fp);
        1:   31:    return 0;
        1:   32:}
        -:   33:
        -:   34:// Main scan function: identifies and processes tokens
function scan called 883 returned 100% blocks executed 55%
      883:   35:int scan(void) {
        -:   36:    char buffer[MAXSTRSIZE];
      883:   37:    int i = 0;
        -:   38:
      883:   39:    memset(buffer, '\0', MAXSTRSIZE);
        -:   40:
        -:   41:    // Skip whitespace and comments
      883:   42:    while (skip_whitespace_and_comments()) {
branch  0 taken 1%
branch  1 taken 99%
        1:   43:        if (cbuf == EOF) {
branch  0 taken 0%
branch  1 taken 100%
        1:   44:            printf("End of file reached at line %d\n", linenum);
        1:   45:            return -1;
        -:   46:        }
        -:   47:    }
        -:   48:
      882:   49:    printf("Current character: %c (Line: %d)\n", cbuf, linenum);
        -:   50:
      882:   51:    switch (cbuf) {
branch  0 taken 43%
branch  1 taken 54%
branch  2 taken 3%
        -:   52:        // Handle symbols directly
        -:   53:        case '+': case '-': case '*': case '=': case '<': case '>': case '(': case ')':
        -:   54:        case '[': case ']': case '{': case '}': case ':': case '.': case ',': case ';': case '!':
      378:   55:            buffer[0] = cbuf;
      378:   56:            cbuf = (char) fgetc(fp);
      378:   57:            return process_symbol(buffer);
        -:   58:
        -:   59:        // Handle string literals
        -:   60:        case '\'':
       26:   61:            printf("Processing string literal starting at line %d\n", linenum);
       26:   62:            return process_string_literal();
        -:   63:
        -:   64:        // Handle keywords, identifiers, and numbers
        -:   65:        default:
      478:   66:            if (isalpha(cbuf)) {  // Keyword/Identifier
branch  0 taken 96%
branch  1 taken 4%
      457:   67:                buffer[0] = cbuf;
     1499:   68:                for (i = 1; (cbuf = (char) fgetc(fp)) != EOF; i++) {
branch  0 taken 0%
branch  1 taken 100%
     1499:   69:                    if (check_token_size(i) == -1) return -1;
branch  0 taken 100%
branch  1 taken 0%
     1499:   70:                    if (isalpha(cbuf) || isdigit(cbuf)) {
branch  0 taken 39%
branch  1 taken 61%
branch  2 taken 21%
branch  3 taken 79%
     1042:   71:                        buffer[i] = cbuf;
     1042:   72:                    } else {
      457:   73:                        break;
        -:   74:                    }
     1042:   75:                }
      457:   76:                printf("Processing identifier/keyword: %s\n", buffer);
      457:   77:                int temp = match_keyword(buffer);
      457:   78:                return (temp != -1) ? temp : process_identifier(buffer);
branch  0 taken 43%
branch  1 taken 57%
        -:   79:            }
        -:   80:
       21:   81:            if (isdigit(cbuf)) {  // Number
branch  0 taken 100%
branch  1 taken 0%
       21:   82:                buffer[0] = cbuf;
       21:   83:                for (i = 1; (cbuf = (char) fgetc(fp)) != EOF; i++) {
branch  0 taken 0%
branch  1 taken 100%
       21:   84:                    if (check_token_size(i) == -1) return -1;
branch  0 taken 100%
branch  1 taken 0%
       21:   85:                    if (isdigit(cbuf)) {
branch  0 taken 100%
branch  1 taken 0%
    #####:   86:                        buffer[i] = cbuf;
    #####:   87:                    } else {
       21:   88:                        break;
        -:   89:                    }
    #####:   90:                }
       21:   91:                printf("Processing number: %s\n", buffer);
       21:   92:                return process_number(buffer);
        -:   93:            }
        -:   94:
        -:   95:            // Handle unexpected tokens
    #####:   96:            printf("Unexpected token: %c at line %d\n", cbuf, linenum);
    #####:   97:            error("Unexpected token encountered");
    #####:   98:            return -1;
        -:   99:    }
      883:  100:}
        -:  101:
        -:  102:// Skip over whitespace and comments
function skip_whitespace_and_comments called 883 returned 100% blocks executed 52%
      883:  103:int skip_whitespace_and_comments(void) {
      883:  104:    while (1) {
     1748:  105:        while (isspace(cbuf)) {
branch  0 taken 49%
branch  1 taken 51%
      856:  106:            if (cbuf == '\n') linenum++;  // Track line breaks
branch  0 taken 84%
branch  1 taken 16%
      856:  107:            cbuf = (char) fgetc(fp);
        -:  108:        }
        -:  109:
        -:  110:        // Handle block comments
      892:  111:        if (cbuf == '{') {
branch  0 taken 0%
branch  1 taken 100%
    #####:  112:            while (cbuf != '}' && cbuf != EOF) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  113:                cbuf = (char) fgetc(fp);
    #####:  114:                if (cbuf == '\n') linenum++;
branch  0 never executed
branch  1 never executed
        -:  115:            }
    #####:  116:            if (cbuf == '}') cbuf = (char) fgetc(fp);
branch  0 never executed
branch  1 never executed
    #####:  117:            continue;
        -:  118:        }
        -:  119:
        -:  120:        // Handle single-line comments
      892:  121:        if (cbuf == '/') {
branch  0 taken 1%
branch  1 taken 99%
        9:  122:            cbuf = (char) fgetc(fp);
        9:  123:            if (cbuf == '/') {
branch  0 taken 0%
branch  1 taken 100%
    #####:  124:                while (cbuf != '\n' && cbuf != EOF) cbuf = (char) fgetc(fp);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  125:                linenum++;
    #####:  126:                cbuf = (char) fgetc(fp);
    #####:  127:                continue;
        -:  128:            }
        -:  129:
        -:  130:            // Handle multi-line comments
        9:  131:            if (cbuf == '*') {
branch  0 taken 100%
branch  1 taken 0%
      202:  132:                while (1) {
      202:  133:                    cbuf = (char) fgetc(fp);
      202:  134:                    if (cbuf == '*' && (cbuf = (char) fgetc(fp)) == '/') {
branch  0 taken 5%
branch  1 taken 95%
branch  2 taken 10%
branch  3 taken 90%
        9:  135:                        cbuf = (char) fgetc(fp);
        9:  136:                        break;
        -:  137:                    }
      193:  138:                    if (cbuf == '\n') linenum++;
branch  0 taken 100%
branch  1 taken 0%
      193:  139:                    if (cbuf == EOF) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  140:                        error("Unterminated multi-line comment.");
    #####:  141:                        return -1;
        -:  142:                    }
        -:  143:                }
        9:  144:                continue;
        -:  145:            } else {
    #####:  146:                break;  // Not a comment, return control to scan
        -:  147:            }
        -:  148:        }
      883:  149:        break;
        -:  150:    }
      883:  151:    return (cbuf == EOF) ? 1 : 0;
      883:  152:}
        -:  153:
        -:  154:// Match keywords in the source
function match_keyword called 457 returned 100% blocks executed 100%
      457:  155:int match_keyword(const char *token_str) {
    10309:  156:    for (int i = 0; i < KEYWORDSIZE; i++) {
branch  0 taken 97%
branch  1 taken 3%
    10049:  157:        if (strcmp(token_str, key[i].keyword) == 0) {
branch  0 taken 2%
branch  1 taken 98%
      197:  158:            return key[i].keytoken;
        -:  159:        }
     9852:  160:    }
      260:  161:    return -1;
      457:  162:}
        -:  163:
        -:  164:// Process identifiers
function process_identifier called 260 returned 100% blocks executed 100%
      260:  165:int process_identifier(const char *token_str) {
      260:  166:    strncpy(string_attr, token_str, MAXSTRSIZE - 1);
      260:  167:    string_attr[MAXSTRSIZE - 1] = '\0';
      260:  168:    return TNAME;  // Identifier token
        -:  169:}
        -:  170:
        -:  171:// Process numbers
function process_number called 21 returned 100% blocks executed 80%
       21:  172:int process_number(const char *token_str) {
       21:  173:    long value = strtol(token_str, NULL, 10);
       21:  174:    if (value <= 32767) {
branch  0 taken 0%
branch  1 taken 100%
       21:  175:        num_attr = (int) value;
       21:  176:    } else {
    #####:  177:        error("Number exceeds maximum allowable value.");
    #####:  178:        return -1;
        -:  179:    }
       21:  180:    return TNUMBER;
       21:  181:}
        -:  182:
        -:  183:// Handle string literals
function process_string_literal called 26 returned 100% blocks executed 75%
       26:  184:int process_string_literal(void) {
       26:  185:    int i = 0;
        -:  186:    char tempbuf[MAXSTRSIZE];
        -:  187:
      385:  188:    while ((cbuf = fgetc(fp)) != EOF) {
branch  0 taken 100%
branch  1 taken 0%
      385:  189:        if (check_token_size(i + 1) == -1) return -1;
branch  0 taken 100%
branch  1 taken 0%
      385:  190:        if (cbuf == '\'') {
branch  0 taken 7%
branch  1 taken 93%
       26:  191:            cbuf = fgetc(fp);
       26:  192:            if (cbuf != '\'') {
branch  0 taken 0%
branch  1 taken 100%
       26:  193:                tempbuf[i] = '\0';
       26:  194:                strncpy(string_attr, tempbuf, MAXSTRSIZE);
       26:  195:                return TSTRING;
        -:  196:            }
    #####:  197:            tempbuf[i++] = '\'';  // Handle escaped quotes
    #####:  198:        } else {
      359:  199:            tempbuf[i++] = cbuf;
        -:  200:        }
        -:  201:    }
        -:  202:    
    #####:  203:    error("Unterminated string literal.");
    #####:  204:    return -1;
       26:  205:}
        -:  206:
        -:  207:// Handle symbol tokens
function process_symbol called 378 returned 100% blocks executed 66%
      378:  208:int process_symbol(char *token_str) {
      378:  209:    switch (token_str[0]) {
branch  0 taken 1%
branch  1 taken 21%
branch  2 taken 0%
branch  3 taken 16%
branch  4 taken 16%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 1%
branch 10 taken 1%
branch 11 taken 2%
branch 12 taken 5%
branch 13 taken 1%
branch 14 taken 0%
branch 15 taken 15%
branch 16 taken 23%
       60:  210:        case '(': return TLPAREN;
       60:  211:        case ')': return TRPAREN;
    #####:  212:        case '{': return TLBRACE;
    #####:  213:        case '}': return TRBRACE;
    #####:  214:        case '[': return TLSQPAREN;
    #####:  215:        case ']': return TRSQPAREN;
        1:  216:        case '+': return TPLUS;
        5:  217:        case '-': return TMINUS;
        6:  218:        case '*': return TSTAR;
       19:  219:        case '=': return TEQUAL;
        -:  220:        case '<':
        3:  221:            if (cbuf == '>') { cbuf = fgetc(fp); return TNOTEQ; }
branch  0 taken 33%
branch  1 taken 67%
        2:  222:            if (cbuf == '=') { cbuf = fgetc(fp); return TLEEQ; }
branch  0 taken 0%
branch  1 taken 100%
        2:  223:            return TLE;
        -:  224:        case '>':
    #####:  225:            if (cbuf == '=') { cbuf = fgetc(fp); return TGREQ; }
branch  0 never executed
branch  1 never executed
    #####:  226:            return TGR;
        -:  227:        case ':':
       55:  228:            if (cbuf == '=') { cbuf = fgetc(fp); return TASSIGN; }
branch  0 taken 62%
branch  1 taken 38%
       21:  229:            return TCOLON;
        1:  230:        case '.': return TDOT;
       87:  231:        case ',': return TCOMMA;
       81:  232:        case ';': return TSEMI;
        -:  233:        default:
    #####:  234:            error("Unrecognized symbol.");
    #####:  235:            return -1;
        -:  236:    }
      378:  237:}
        -:  238:
        -:  239:// Check if token size exceeds limits
function check_token_size called 1905 returned 100% blocks executed 75%
     1905:  240:int check_token_size(int length) {
     1905:  241:    if (length >= MAXSTRSIZE) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  242:        error("Token exceeds maximum size.");
    #####:  243:        return -1;
        -:  244:    }
     1905:  245:    return 1;
     1905:  246:}
        -:  247:
        -:  248:// Error handling
function error called 0 returned 0% blocks executed 0%
    #####:  249:int error(char *mes) {
    #####:  250:    fprintf(stderr, "Error: %s at line %d\n", mes, linenum);
    #####:  251:    exit(EXIT_FAILURE);
        -:  252:    return -1;
        -:  253:}
        -:  254:
        -:  255:// Clean up after scanning
function end_scan called 1 returned 100% blocks executed 100%
        1:  256:void end_scan(void) {
        1:  257:    if (fp != NULL) {
branch  0 taken 100%
branch  1 taken 0%
        1:  258:        fclose(fp);
        1:  259:        fp = NULL;
        1:  260:    }
        1:  261:}
