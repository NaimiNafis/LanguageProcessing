        -:    0:Source:scan.c
        -:    0:Graph:scan.gcno
        -:    0:Data:scan.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <ctype.h>
        -:    4:#include <string.h>
        -:    5:#include "scan.h"
        -:    6:
        -:    7:FILE *fp;  // File pointer to handle input
        -:    8:char string_attr[MAXSTRSIZE];  // Store string attributes
        -:    9:int num_attr;  // Store numerical attributes
        -:   10:char cbuf = '\0';  // Buffer for the current character being read
        -:   11:int linenum = 1;  // Line number tracker
        -:   12:
        -:   13:// Helper function declarations
        -:   14:int match_keyword(const char *token_str);
        -:   15:int process_identifier(const char *token_str);
        -:   16:int process_symbol(char *token_str);
        -:   17:int process_number(const char *token_str);
        -:   18:int process_string_literal(void);
        -:   19:int skip_whitespace_and_comments(void);
        -:   20:int check_token_size(int length);
        -:   21:
        -:   22:// Initialize file reading
function init_scan called 2 returned 100% blocks executed 75%
        2:   23:int init_scan(char *filename) {
        2:   24:    fp = fopen(filename, "r");
        2:   25:    if (fp == NULL) {
branch  0 taken 0%
branch  1 taken 100%
    #####:   26:        error("Unable to open file.");
    #####:   27:        return -1;
        -:   28:    }
        2:   29:    linenum = 1;
        2:   30:    cbuf = (char) fgetc(fp);
        2:   31:    return 0;
        2:   32:}
        -:   33:
        -:   34:// Main scan function: identifies and processes tokens
function scan called 1766 returned 100% blocks executed 55%
     1766:   35:int scan(void) {
        -:   36:    char buffer[MAXSTRSIZE];
     1766:   37:    int i = 0;
        -:   38:
     1766:   39:    memset(buffer, '\0', MAXSTRSIZE);
        -:   40:
        -:   41:    // Skip whitespace and comments
     1766:   42:    while (skip_whitespace_and_comments()) {
branch  0 taken 1%
branch  1 taken 99%
        2:   43:        if (cbuf == EOF) {
branch  0 taken 0%
branch  1 taken 100%
        2:   44:            printf("End of file reached at line %d\n", linenum);
        2:   45:            return -1;
        -:   46:        }
        -:   47:    }
        -:   48:
     1764:   49:    //printf("Current character: %c (Line: %d)\n", cbuf, get_linenum());
        -:   50:
     1764:   51:    switch (cbuf) {
branch  0 taken 43%
branch  1 taken 54%
branch  2 taken 3%
        -:   52:        // Handle symbols directly
        -:   53:        case '+': case '-': case '*': case '=': case '<': case '>': case '(': case ')':
        -:   54:        case '[': case ']': case '{': case '}': case ':': case '.': case ',': case ';': case '!':
      756:   55:            buffer[0] = cbuf;
      756:   56:            cbuf = (char) fgetc(fp);
      756:   57:            return process_symbol(buffer);
        -:   58:
        -:   59:        // Handle string literals
        -:   60:        case '\'':
       52:   61:            //printf("Processing string literal starting at line %d\n", get_linenum());
       52:   62:            return process_string_literal();
        -:   63:
        -:   64:        // Handle keywords, identifiers, and numbers
        -:   65:        default:
      956:   66:            if (isalpha(cbuf)) {  // Keyword/Identifier
branch  0 taken 96%
branch  1 taken 4%
      914:   67:                buffer[0] = cbuf;
     2998:   68:                for (i = 1; (cbuf = (char) fgetc(fp)) != EOF; i++) {
branch  0 taken 0%
branch  1 taken 100%
     2998:   69:                    if (check_token_size(i) == -1) return -1;
branch  0 taken 100%
branch  1 taken 0%
     2998:   70:                    if (isalpha(cbuf) || isdigit(cbuf)) {
branch  0 taken 39%
branch  1 taken 61%
branch  2 taken 21%
branch  3 taken 79%
     2084:   71:                        buffer[i] = cbuf;
     2084:   72:                    } else {
      914:   73:                        break;
        -:   74:                    }
     2084:   75:                }
      914:   76:                //printf("Processing identifier/keyword: %s at line %d\n", buffer, get_linenum());
      914:   77:                int temp = match_keyword(buffer);
      914:   78:                return (temp != -1) ? temp : process_identifier(buffer);
branch  0 taken 43%
branch  1 taken 57%
        -:   79:            }
        -:   80:
       42:   81:            if (isdigit(cbuf)) {  // Number
branch  0 taken 100%
branch  1 taken 0%
       42:   82:                buffer[0] = cbuf;
       42:   83:                for (i = 1; (cbuf = (char) fgetc(fp)) != EOF; i++) {
branch  0 taken 0%
branch  1 taken 100%
       42:   84:                    if (check_token_size(i) == -1) return -1;
branch  0 taken 100%
branch  1 taken 0%
       42:   85:                    if (isdigit(cbuf)) {
branch  0 taken 100%
branch  1 taken 0%
    #####:   86:                        buffer[i] = cbuf;
    #####:   87:                    } else {
       42:   88:                        break;
        -:   89:                    }
    #####:   90:                }
       42:   91:                //printf("Processing number: %s at line %d\n", buffer, get_linenum());
       42:   92:                return process_number(buffer);
        -:   93:            }
        -:   94:
        -:   95:            // Handle unexpected tokens
    #####:   96:            printf("Unexpected token: %c at line %d\n", cbuf, linenum);
    #####:   97:            error("Unexpected token encountered");
    #####:   98:            return -1;
        -:   99:    }
     1766:  100:}
        -:  101:
        -:  102:// Skip over whitespace and comments
function skip_whitespace_and_comments called 1766 returned 100% blocks executed 52%
     1766:  103:int skip_whitespace_and_comments(void) {
     1766:  104:    while (1) {
     3496:  105:        while (isspace(cbuf)) {
branch  0 taken 49%
branch  1 taken 51%
     1712:  106:            if (cbuf == '\n') linenum++;  // Track line breaks
branch  0 taken 84%
branch  1 taken 16%
     1712:  107:            cbuf = (char) fgetc(fp);
        -:  108:        }
        -:  109:
        -:  110:        // Handle block comments
     1784:  111:        if (cbuf == '{') {
branch  0 taken 0%
branch  1 taken 100%
    #####:  112:            while (cbuf != '}' && cbuf != EOF) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  113:                cbuf = (char) fgetc(fp);
    #####:  114:                if (cbuf == '\n') linenum++;
branch  0 never executed
branch  1 never executed
        -:  115:            }
    #####:  116:            if (cbuf == '}') cbuf = (char) fgetc(fp);
branch  0 never executed
branch  1 never executed
    #####:  117:            continue;
        -:  118:        }
        -:  119:
        -:  120:        // Handle single-line comments
     1784:  121:        if (cbuf == '/') {
branch  0 taken 1%
branch  1 taken 99%
       18:  122:            cbuf = (char) fgetc(fp);
       18:  123:            if (cbuf == '/') {
branch  0 taken 0%
branch  1 taken 100%
    #####:  124:                while (cbuf != '\n' && cbuf != EOF) cbuf = (char) fgetc(fp);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  125:                linenum++;
    #####:  126:                cbuf = (char) fgetc(fp);
    #####:  127:                continue;
        -:  128:            }
        -:  129:
        -:  130:            // Handle multi-line comments
       18:  131:            if (cbuf == '*') {
branch  0 taken 100%
branch  1 taken 0%
      404:  132:                while (1) {
      404:  133:                    cbuf = (char) fgetc(fp);
      404:  134:                    if (cbuf == '*' && (cbuf = (char) fgetc(fp)) == '/') {
branch  0 taken 5%
branch  1 taken 95%
branch  2 taken 10%
branch  3 taken 90%
       18:  135:                        cbuf = (char) fgetc(fp);
       18:  136:                        break;
        -:  137:                    }
      386:  138:                    if (cbuf == '\n') linenum++;
branch  0 taken 100%
branch  1 taken 0%
      386:  139:                    if (cbuf == EOF) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  140:                        printf("Warning: Unterminated multi-line comment at line %d, skipping...\n", linenum);
    #####:  141:                        return 1;
        -:  142:                    }
        -:  143:                }
       18:  144:                continue;
        -:  145:            } else {
    #####:  146:                break;  // Not a comment, return control to scan
        -:  147:            }
        -:  148:        }
     1766:  149:        break;
        -:  150:    }
     1766:  151:    return (cbuf == EOF) ? 1 : 0;
     1766:  152:}
        -:  153:
        -:  154:// Match keywords in the source
function match_keyword called 914 returned 100% blocks executed 100%
      914:  155:int match_keyword(const char *token_str) {
    20618:  156:    for (int i = 0; i < KEYWORDSIZE; i++) {
branch  0 taken 97%
branch  1 taken 3%
    20098:  157:        if (strcmp(token_str, key[i].keyword) == 0) {
branch  0 taken 2%
branch  1 taken 98%
      394:  158:            return key[i].keytoken;
        -:  159:        }
    19704:  160:    }
      520:  161:    return -1;
      914:  162:}
        -:  163:
        -:  164:// Process identifiers
function process_identifier called 520 returned 100% blocks executed 100%
      520:  165:int process_identifier(const char *token_str) {
      520:  166:    strncpy(string_attr, token_str, MAXSTRSIZE - 1);
      520:  167:    string_attr[MAXSTRSIZE - 1] = '\0';
      520:  168:    return TNAME;  // Identifier token
        -:  169:}
        -:  170:
        -:  171:// Process numbers
function process_number called 42 returned 100% blocks executed 80%
       42:  172:int process_number(const char *token_str) {
       42:  173:    long value = strtol(token_str, NULL, 10);
       42:  174:    if (value <= 32767) {
branch  0 taken 0%
branch  1 taken 100%
       42:  175:        num_attr = (int) value;
       42:  176:    } else {
    #####:  177:        error("Number exceeds maximum allowable value.");
    #####:  178:        return -1;
        -:  179:    }
       42:  180:    return TNUMBER;
       42:  181:}
        -:  182:
        -:  183:// Handle string literals
function process_string_literal called 52 returned 100% blocks executed 75%
       52:  184:int process_string_literal(void) {
       52:  185:    int i = 0;
        -:  186:    char tempbuf[MAXSTRSIZE];
        -:  187:
      770:  188:    while ((cbuf = fgetc(fp)) != EOF) {
branch  0 taken 100%
branch  1 taken 0%
      770:  189:        if (check_token_size(i + 1) == -1) return -1;
branch  0 taken 100%
branch  1 taken 0%
      770:  190:        if (cbuf == '\'') {
branch  0 taken 7%
branch  1 taken 93%
       52:  191:            cbuf = fgetc(fp);
       52:  192:            if (cbuf != '\'') {
branch  0 taken 0%
branch  1 taken 100%
       52:  193:                tempbuf[i] = '\0';
       52:  194:                strncpy(string_attr, tempbuf, MAXSTRSIZE);
       52:  195:                return TSTRING;
        -:  196:            }
    #####:  197:            tempbuf[i++] = '\'';  // Handle escaped quotes
    #####:  198:        } else {
      718:  199:            tempbuf[i++] = cbuf;
        -:  200:        }
        -:  201:    }
        -:  202:    
    #####:  203:    error("Unterminated string literal.");
    #####:  204:    return -1;
       52:  205:}
        -:  206:
        -:  207:// Handle symbol tokens
function process_symbol called 756 returned 100% blocks executed 66%
      756:  208:int process_symbol(char *token_str) {
      756:  209:    switch (token_str[0]) {
branch  0 taken 1%
branch  1 taken 21%
branch  2 taken 0%
branch  3 taken 16%
branch  4 taken 16%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 0%
branch  8 taken 0%
branch  9 taken 1%
branch 10 taken 1%
branch 11 taken 2%
branch 12 taken 5%
branch 13 taken 1%
branch 14 taken 0%
branch 15 taken 15%
branch 16 taken 23%
      120:  210:        case '(': return TLPAREN;
      120:  211:        case ')': return TRPAREN;
    #####:  212:        case '{': return TLBRACE;
    #####:  213:        case '}': return TRBRACE;
    #####:  214:        case '[': return TLSQPAREN;
    #####:  215:        case ']': return TRSQPAREN;
        2:  216:        case '+': return TPLUS;
       10:  217:        case '-': return TMINUS;
       12:  218:        case '*': return TSTAR;
       38:  219:        case '=': return TEQUAL;
        -:  220:        case '<':
        6:  221:            if (cbuf == '>') { cbuf = fgetc(fp); return TNOTEQ; }
branch  0 taken 33%
branch  1 taken 67%
        4:  222:            if (cbuf == '=') { cbuf = fgetc(fp); return TLEEQ; }
branch  0 taken 0%
branch  1 taken 100%
        4:  223:            return TLE;
        -:  224:        case '>':
    #####:  225:            if (cbuf == '=') { cbuf = fgetc(fp); return TGREQ; }
branch  0 never executed
branch  1 never executed
    #####:  226:            return TGR;
        -:  227:        case ':':
      110:  228:            if (cbuf == '=') { cbuf = fgetc(fp); return TASSIGN; }
branch  0 taken 62%
branch  1 taken 38%
       42:  229:            return TCOLON;
        2:  230:        case '.': return TDOT;
      174:  231:        case ',': return TCOMMA;
      162:  232:        case ';': return TSEMI;
        -:  233:        default:
    #####:  234:            error("Unrecognized symbol.");
    #####:  235:            return -1;
        -:  236:    }
      756:  237:}
        -:  238:
        -:  239:// Check if token size exceeds limits
function check_token_size called 3810 returned 100% blocks executed 75%
     3810:  240:int check_token_size(int length) {
     3810:  241:    if (length >= MAXSTRSIZE) {
branch  0 taken 0%
branch  1 taken 100%
    #####:  242:        error("Token exceeds maximum size.");
    #####:  243:        return -1;
        -:  244:    }
     3810:  245:    return 1;
     3810:  246:}
        -:  247:
        -:  248:// Error handling
function error called 0 returned 0% blocks executed 0%
    #####:  249:int error(char *mes) {
    #####:  250:    fprintf(stderr, "Error: %s at line %d\n", mes, linenum);
    #####:  251:    exit(EXIT_FAILURE);
        -:  252:    return -1;
        -:  253:}
        -:  254:
        -:  255:// Used for error-reporting function (parser or error handler)
function end_scan called 2 returned 100% blocks executed 100%
        2:  256:int get_linenum(void) {
        2:  257:    return linenum;
branch  0 taken 100%
branch  1 taken 0%
        2:  258:}
        2:  259:
        2:  260:// Clean up after scanning
        2:  261:void end_scan(void) {
        -:  262:    if (fp != NULL) {
        -:  263:        fclose(fp);
        -:  264:        fp = NULL;
        -:  265:    }
        -:  266:}
